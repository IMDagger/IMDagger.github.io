Как выжить в катастрофе
=======================
:date: 2010-09-14 13:34:13
:tags: tdb, ошибка, исправление, пользователи, нарушение, python, удача, ldb, samba4
:category: text
:author: IMDagger
:yaru-link: http://imdagger.ya.ru/replies.xml?item_no=1118

Что дано? Дана база users.ldb от Samba4-alpha8 размером в 73154560
байтов. Это LDB данные в хранилище типа TDB. Исходники показали, что TDB
записи не очень сложные для понимания. Да и LDB записи для меня теперь
не страшны. База повреждена. Как я это определил? было специфическое
поведение (**ВСЕ ОПЕРАЦИИ ПРОВОДИЛИСЬ НА КОПИИ БАЗЫ!!!**):

.. code-block:: console

    [root@alpha tmp]# /opt/bin/tdbtool
    tdb> open users.ldb
    tdb> info
    Error = Corrupt database
    tdb> check
    Integrity check for the opened database failed.

База открывалась через /opt/bin/ldbedit -H /tmp/users.ldb , но не
хватало огромного количества пользователей. База казалась оборванной.
Аналогичная ситуация наблюдалась при подключении к серверу по протоколу
LDAP — :code:`/opt/bin/ldbedit -H ldap://localhost`. Как можно было это всё
увидеть не со стороны сервера? Да очень просто: пользователи могли
входить в систему, работать как и раньше, но как только дело касалось
установки прав на какую-либо директорию, то PDC отвечал, что в LDAP
дереве не найден такой пользователь. Остались доступными лишь
пользователи, записи которых видны через ldbedit. Ещё периодически
происходила блокировка части записей и в логах Samba сыпалось (которая
проявлялась, как недоступный сервер при вводе в домен новой машинки):

    | [Wed Sep  8 15:51:35 2010 EEST, 0 lib/ldb\_wrap.c:66:ldb\_wrap\_debug()]
    | ldb: ltdb: tdb(/opt/private/users.ldb): tdb\_rec\_read bad magic 0xd9fee666 at offset=42488496

Я вручную выправлял какждый раз этот magic на верный (как уже я
ранее писал в блоге). Это было похоже, что я даю обезболивающее
пациенту, у которого открытый перелом ноги. Ему вроде становится немного
легче, но ходить он всё равно не может. И если ничего не предпринять
серьёзнее, то он умрёт в конце-концов.

Один из приятных моментов, что Samba расширяет TDB-хранилище
большими порциями и поэтому бэкап базы полугодичной давности хотя бы
похож размером и частично расположением записей на текущую. Это мне
помогло ориентироваться, что где и как.

Для начала пришлось наловчиться пользоваться утилитой tdbtool,
отныне это наш друг и помощник. Это низкоуровневая утилита по работе с
TDB записями. Сначала у меня с ней не заладилось, я хотел получить по
ключу одну запись просто посмотреть, но утилита выдавала ошибку fetch. В
интернете я всё же смог найти, что нужно просто добавить ключу
терминирущий ноль, т.е.:

    | *я писал*
    | open users.ldb
    | show @INDEX:CN:M120
    | ***оно говорило ошибку***
    | *я написал*
    | show @INDEX:CN:M120\\0
    | *и получил данные о записи: её размер , размер ключа*

Я был в шоке, что у меня всё разрушено и бэкап этой базы я начал
делать слишком поздно (я думал, что это сделал уже другой человек, но
оказалось, что это не так). Но посопев и покряхтев я взялся за
исследования и осознание TDB в целях прозрения. Меня успокаивало то, что
хотя бы Samba4 может считывать записи и пользователи входят и всё более
менее работает.

Я сделал дамп битой базы:

    | /opt/bin/tdbtool >dump
    | open users.ldb
    | dump
    | q

В конце файла dump меня ждал сюрприз (уже по размеру было видно,
что файл небольшой и оборван)::

        key 27 bytes
        DN=@INDEX:US(...x<..l.....
        data 88 bytes
        [000] 00 36 00 00 00 4B D3 C5  D9 99 19 01 26 44 4E 3D  .6...K.. ....&DN=
        [010] 40 49 4E 44 45 58 3A 55  53 4E 43 52 45 41 54 45  @INDEX:U SNCREATE
        [020] 44 3A 31 30 37 36 39 34  00 67 19 01 26 01 00 00  D:107694 .g..&..
        [030] 00 40 49 4E 44 45 58 3A  55 53 4E 43 52 45 41 54  .@INDEX: USNCREAT
        [040] 45 44 3A 31 30 37 36 39  34 00 40 49 44 58 50 54  ED:10769 4.@IDXPT
        [050] 52 00 01 00 00 00 04 00                           R......

Ясно, что записи с ключом *@INDEX:US(…x<..l…..* не бывает а дальше в
теле записи насторожило то, что снова начинается TDB запись. Это можно
увидеть по magic-ключу 0x99 0x19 0x01 0x26. И по тому, что тело не
начинается на 0x67 0x19 0x01 0x26, а эти байты можно найти чуть дальше.
С таких байтов начинаются все тела записей в TDB хранилище.

.. class:: text-center

|image0|

Сперва я решил разблокировать все запись и набросал очень простой и
тупой скрипт на Python (**ОСТОРОЖНО С НИМ**):

.. code-block:: python

        import sys, os

        flag = True

        base = file('users.ldb', 'rb+')
        patch = '\x99\x19\x01\x26'

        while flag:
            os.system("/opt/bin/tdbbackup -v users.ldb >result.txt")

            flag = False
            for l in file('result.txt'):
            if 'offset=' in l and '0xd9fee666':
                flag = True
                pos = int(l[l.index('offset=') + len('offset='):])
                base.seek(pos)
                data = base.read(128)
                try:
                dst = data.index('\x66\xe6\xfe\xd9')

                base.seek(pos + dst)
                base.write(patch)
                base.flush()
                except:
                print 'error'
                sys.exit(1)
            print pos

Сценарий открывает базу users.ldb в текущей директории и использует
утилиту tdbbackup для определения заблокированных участков.
Восстанавливать нам всё равно не откуда, но… зато эта программулина
говорит, что bad magic в позиции offset такой-то. Скрипт работает до тех
пор, пока /opt/bin/tdbbackup (<b>путь в скрипте прописать свой!</b>) не
согласится, что всё хорошо. Утилита будет выдавать, что users.ldb.bak не
найден, но ничего страшного, у нас всё равно его нет и не для этого мы
её используем, она просто может найти все места блокировки.

После разблокировки нужно запустить снова tdbtool:

    | open users.ldb >dump
    | dump
    | q

На этот раз файл dump будет соизмерим с users.ldb, там будут все
записи. Но.. как обычно всё не так хорошо… Я нашёл целый участок
разрушенных записей. Начиная с места обрыва. Но мне повезло и я нашёл
продолжение, где всё ок. Просто на глаз пролистал много строк вниз.
Большинство плохих записей было похоже на (т.е. содержало ключ
начинающийся с INDE$)::

        key 62 bytes
        DN=@INDE$...l.q...../...r....>.U...&DN=@INDEX:OBJECTGUID::Bo3j
        data 129 bytes
        [000] 7A 6A 4A 45 33 30 4B 56  53 73 4F 54 4C 52 78 45  zjJE30KV SsOTLRxE
        [010] 54 77 3D 3D 00 67 19 01  26 01 00 00 00 40 49 4E  Tw==.g.. &....@IN
        [020] 44 45 58 3A 4F 42 4A 45  43 54 47 55 49 44 3A 3A  DEX:OBJE CTGUID::
        [030] 42 6F 33 6A 7A 6A 4A 45  33 30 4B 56 53 73 4F 54  Bo3jzjJE 30KVSsOT
        [040] 4C 52 78 45 54 77 3D 3D  00 40 49 44 58 00 01 00  LRxETw== .@IDX..
        [050] 00 00 30 00 00 00 43 4E  3D 41 64 6D 69 6E 69 73  ..0...CN =Adminis
        [060] 74 72 61 74 6F 72 2C 43  4E 3D 55 73 65 72 73 2C  trator,C N=Users,
        [070] 44 43 3D 67 72 6C 2C 44  43 3D 75 6E 69 62 65 6C  DC=grl,D C=unibel
        [080] 2C                                                ,

Тут подтверждалась моя гипотеза, что за первой записью следуеть
сразу вторая запись и что у первой записи неверная длина ключа и тела.
Меня вдруг насторожило то, что я нашёл некоторые из записей, которые
внутри тела плохих TDB записей, нетронутыми и в нормальном виде. Вообще
вся структура TDB грубо говоря представляет из себя простой список:

    [**запись 1**: указатель на 2] -> [**запись 2**: указатель 3] -> …
    -> [**запись N**: 0 стоп]

Но записи разбросаны по всему файлу. Я сделал предположение, что
после того, как система бесперебойного питания отказала (а ныне на
сервере к сожалению стоит на SmartUPS, который скончался, а обычный), а
Samba в этот момент что-то делала с записями, то появилась одна или
несколько «косячных записей». Возможно Samba просто их не стёрла.
Получилась цепочка с самопересечением:

    [**запись 1**: указатель на 2] -> [**запись 2**: указатель на 3] ->
    … -> [**запись N**: указатель на кусок записи 1] -> [**кусок записи
    1**: указатель на кусок записи 2] -> и т.д. как-то так

Первую не разбитую запись я обнаружил в файле dump, она была
особенной, т.к. перед ней шла запись с длиной ключа 0 и телом 0::

        key 0 bytes

        data 0 bytes

        key 35 bytes
        DN=@INDEX:SN::0KHQkNCf0KDQq9Ca0J4=
        data 133 bytes
        [000] 67 19 01 26 01 00 00 00  40 49 4E 44 45 58 3A 53  g..&... @INDEX:S
        [010] 4E 3A 3A 30 4B 48 51 6B  4E 43 66 30 4B 44 51 71  N::0KHQk NCf0KDQq
        [020] 39 43 61 30 4A 34 3D 00  40 49 44 58 00 01 00 00  9Ca0J4= @IDX...
        [030] 00 4F 00 00 00 43 4E 3D  41 72 74 69 6F 6D 20 53  .O...CN= Artiom S
        [040] 61 70 72 79 6B 6F 2C 4F  55 3D 49 50 5F 31 30 2C  apryko,O U=IP_10,
        [050] 4F 55 3D 32 30 31 30 2C  4F 55 3D 53 74 75 64 65  OU=2010, OU=Stude
        [060] 6E 74 73 2C 4F 55 3D 50  65 6F 70 6C 65 2C 44 43  nts,OU=P eople,DC
        [070] 3D 67 72 6C 2C 44 43 3D  75 6E 69 62 65 6C 2C 44  =grl,DC= unibel,D
        [080] 43 3D 62 79 00                                    C=by

Я сделал следующее: взял запись 1 (целая запись, которая указывает
на первую битую) и взял запись 2 (первая целая запись после битых). А
затем в поле next записи 1 прописал указатель на запись 2. Как я это
сделал? Очень просто, достаточно понимания TDB и LDB:

-  нашёл в файле DN=@INDEX:SN::0KHQkNCf0KDQq9Ca0J4= запись
-  её можно будет определить по & впереди (т.к. 67 19 01 26 начало
   записи)
-  нашёл её magic (он до тела! его нет в dump, нужно смотреть в hex
   редакторе), т.е. 0x99 0x19 0x01 0x26
-  отступил назад 20 байтов от начала magic
-  это и есть начало записи

Я посмотрел адрес начала записи 2, повторил операцию для записи 1. И
прописал в поле next для 1 указатель на 2. Грубо говоря я «зашил» дырку,
т.е. выбросил участок кривых ссылок:

.. class:: text-center

|image1|

::

   было для 1:
   14 BA 44 02 | A4 00 00 00 | 1C 00 00 00 | 5C 00 00 00 | 80 46 3B CC | 99 19 01 26 | ключ и данные ...
   стало для 1:
   C0 8E 41 02 | A4 00 00 00 | 1C 00 00 00 | 5C 00 00 00 | 80 46 3B CC | 99 19 01 26 | ключ и данные ...

Понимание полей можно получить из исходного кода Samba4, первое поле
это адрес следующей записи, третье — размер ключа, четвёртое — размер
данных после ключа. Ключ заканчивается терминирующим нулём.

После такого сшивания остаток записей подхватился и Samba4 стала
работать вменяемо. А мёртвые записи надеюсь так и останутся в базе и не
будут мне больше мешать. Надеюсь призраки записей не придут ко мне :).

.. |image0| image:: http://img-fotki.yandex.ru/get/5202/imdagger.8/0_40322_7b4fb56_L
   :target: http://fotki.yandex.ru/users/imdagger/view/262946/
.. |image1| image:: http://img-fotki.yandex.ru/get/4605/imdagger.8/0_40321_ff0dc7f4_L
   :target: http://fotki.yandex.ru/users/imdagger/view/262945/
