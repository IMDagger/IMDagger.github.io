Проецирование при наследовании
==============================
:date: 2010-01-23 19:09:41
:tags: наследование, проецирование, hibernate
:category: text
:author: IMDagger
:yaru-link: http://imdagger.ya.ru/replies.xml?item_no=625

У меня есть два класса Pupil и Team, которые являются потомками
класса User. Если я пытаюсь получить список пользователей из User, то
мне нужно, чтобы это было объединение (UNION) двух таблиц из Pupil и
Team. Ещё нужно, чтобы HQL-запросах для классов Pupil и Team в
отдельности получать результаты тоже, плюс объединение (JOIN) с другими
таблицами. Ну и на последок, что и доставило неудобвства: нужно
использовать в SQL-запросе и при этом User должен придерживаться
стратегии один класс — одна таблица. Так вышло, что мне ещё и нужно два
свойство getName, которое есть в обоих классах, но проецируется на
разные колонки.

Псевдоним на возвращаемый JOIN-присоединённый класс User к SubCell
классу был объявлен в запросе **sql-query** в subcells.hbm.xml как
:code:`<return-join alias="user" property="subCell.user">`, псевдоним subCell в
данном случае отсылка к объявленному возвращаемому типу объектов класса
SubCell. Когда я начал модифицировать запрос, то столкнулся с проблемой,
что у меня :code:`Pupil.getName` и :code:`Team.getName` возможно записать только одним
способом :code:`{user.name}`. Естественно Hibernate вместо этого псевдонима
подставил только одно значение из первого попавшегося класса (выбирал из
Pupil и Team). Вот и встала делема, как оставить свойство getName, но
при этой обратиться к скрывшемуся полю.

Нашёл выход, возможно не самый лучший и красивый, но верный. Дело в
том, что через псевдоним (alias) user можно получить доступ не только к
свовствам класса User, но и Pupil, Team и других наследников. Главное,
чтобы имена не перекрывались.

Выход из ситуации заключается в создании функций getName и setName,
но скрытых при помощи декоратора :D аннотации :code:`@Transient`. Затем
создаются функции getTeamName и setTeamName, которые используют свойство
**name**, но для них указана аннотация @Column для проецирования на БД.

Теперь, чтобы наполнять классы типа Team  нужно извлекать данные в
поле с именем :code:`{user.teamName}`, а если нужны данные для Pupil, то просто
:code:`{user.name}` (если бы классов наследников было больше, то лучше вариант
:code:`{user.pupilName}` и создание методов аналогично алгоритму описанному
выше).
