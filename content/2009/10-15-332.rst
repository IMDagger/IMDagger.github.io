Прокол
======
:date: 2009-10-15 17:00:23
:tags: java
:category: text
:author: IMDagger
:yaru-link: http://imdagger.ya.ru/replies.xml?item_no=332

Когда я делал черновой класс Cell, то добавил туда метод
getVersionObject, который возвращал объект версии ячейки (SQL-сервер сам
увеличивал это значение у себя):

.. code-block:: java

    public Version getVersionObject() {
        return new Version(timeStamp);
    }

На что радостно при загрузке страницы Apache заявил, что не может
найти метод set для versionObject. Поразмыслив я пришёл в выводу, что
это же bean и Hibernate пытается инициализировать и это поле потому, что
название метода начинается на get. Я попытался добавить setVersionObject
(хотя мне это не требовалось, просто добавил для проверки), но Hibernate
заявил, что не знает как инициализировать versionObject на основании
запроса, т.к. такого поля в таблице нет. Чтобы решить эту проблему я
переименовал метод в versionObject. После этого библиотека перестала
думать, что этот метод относится к бину.

.. code-block:: java

    public Version versionObject() {
        return new Version(timeStamp);
    }

Потом я прокололся на том, что передал в JSP представление объект
класса Row, который реализует интерфейс Iterable. Но выпала ошибка:

.. code-block:: java

    javax.servlet.jsp.JspTagException: Don't know how to iterate over supplied "items" in &lt;forEach&gt;
      org.apache.taglibs.standard.tag.common.core.ForEachSupport.toForEachIterator(ForEachSupport.java:274)
      org.apache.taglibs.standard.tag.common.core.ForEachSupport.supportedTypeForEachIterator(ForEachSupport.java:238)
    org.apache.taglibs.standard.tag.common.core.ForEachSupport.prepare(ForEachSupport.java:155)

А нужно было передать не объект, а его итератор:

.. code-block:: java

    modelAndView.addObject("row", oneRow.iterator());

Но на этом мучения не закончились. Возникла проблема, что объекты
кешировались при помощи EhCache, но мой код каждый раз считал данные
оттуда устаревшими. Постепенно подозрения стали падать на небольшой
класс Version, я никак не хотел верить, что там есть ошибка :del:`да-да я его
почти не тестировал, он же черновой`...

.. code-block:: java

    @Override
    public int compareTo(Object o) {
        Version other = (Version) o;
        byte[] ovs = other.get();
        for (int i = 0; i < ts.length; i++) {
            if (ts[i] < ovs[i])
                return -1;
            else if (ts[i] > ovs[i])
                return +1;
        }
        return 0;
     }

Да, названия переменных кривые x-D, но оно и сделано по-быстрому,
проверить прототип. Казалось проблемы нет, но я же забыл, что в Java
значения типа byte лежат на отрезке :code:`-128 … 127`. Поэтому мои массивы
сравнивались неверно, а обнаружил лишь благодаря тому, что в рабочей
базе оказались два значения отличающиеся только последним байтом: в
одном :code:`0x81`, а во втором :code:`0x7F` :P. И моя функция говорила, что
первое меньше второго. Пришлось поправить её, но в Java нет беззнаковых
типов, поэтому решил вопрос временно так:

.. code-block:: java

    @Override
    public int compareTo(Object o) {
        Version other = (Version) o;
        byte[] ovs = other.get();
        for (int i = 0; i < ts.length; i++)  {
            int tsByte = ((int)ts[i] + 256) % 256;
            int ovsByte = ((int)ovs[i] + 256) % 256;
            if (tsByte < ovsByte)
                return -1;
             else if (tsByte > ovsByte)
                return +1;
        }
        return 0;
    }
