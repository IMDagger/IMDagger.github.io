Python и сокеты
===============
:date: 2009-09-01 16:44:23
:tags: python, сокет
:category: text
:author: IMDagger
:yaru-link: http://imdagger.ya.ru/replies.xml?item_no=183

У Samba 4 всё ещё почему-то нет поддержки RPC для net user, чтобы менять
пароли удалённо с виндовой машины. Т.к. людям это очень нужно было, то я
был вынужден сделать небольшой сервис, который принимал бы запросы на
смену пароля от моего самодельного Java клиента со Swing интерфейсом.
Сервер смены пароля написан на основе *setpassword* (чтобы не
разбираться как работать с ldb-backend :) ) из стандартной поставки
вместе с Samba. Мне оставалось лишь написать часть, которая бы работала
с сокетами. Сначала я начал писать свой велосипед на основе
:code:`socket.socket`, но потом обратил внимание на модуль :code:`SocketServer`.
Этот модуль предоставляет классы для удобной работы с сокетами
различными способами, и он достаточно гибок. Сначала я взял за основу
:code:`TCPServer`, начал в нём перегружать методы. Потом подумал, что мне
нужно обслуживать много клиентов сразу, поэтому нашёл в исходниках
модуля класс :code:`ForkingTCPServer` (есть и :code:`ThreadingTCPServer`),
который использует :code:`fork` для каждого нового соединения. Но я понял,
что в связи с тем, что мне нужно просто обработать довольно несложный
запрос, то мне не стоит перекрывать методы этих классов. Для таких целей
вторым параметром для инициализации объекта класса ForkingTCPServer
передаётся класс обработчика. Мне показался удобным
:code:`StreamRequestHandler` (есть и другие, например, для UDP), поэтому я
его взял за основу:

.. code-block:: python

    ...
    class PasswordChanger(StreamRequestHandler):
        ...
        def handle(self):
            ...
    config = '', 3333
    server = ForkingTCPServer(config, PasswordChanger)
    server.serve_forever()

Класс StreamRequestHandler предоставляет свойства :code:`rfile` и :code:`wfile`.
Первое — поток для чтения (данные от клиента), а второе — поток для
передачи ответа клиенту. Самое приятное, что они поддерживают интерфейс
стандартного типа :code:`file`. Т.е. можно работать будто это просто файлы
на диске! В методе :code:`handle` нужно произвести чтение данных от клиента и
записать в поток ответ (можно и не делать этого :), но никто читать за
нас их не будет).

Я столкнулся с тем, что сокет не переиспользовался, и система не давала
открыть сокет, если я завершил программу по :kbd:`Ctrl+C`. Но для этого у
класса :code:`ForkingTCPServer` есть свойство :code:`allow\_reuse\_address`.
Пришлось его выставить в значение **True**. Т.к. этот сервис будет
единственным на таком порту, но можно не беспокоиться, что вторая копия
переоткроет порт.
