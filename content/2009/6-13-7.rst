Устройство "текстовых текстур" в Blender
========================================
:date: 2009-06-13 20:28:30
:tags: bge, изнутри, устройство, bfnt, текст
:category: text
:author: IMDagger
:yaru-link: http://imdagger.ya.ru/replies.xml?item_no=7

Недавно прочитал интересную
`запись <http://blender-ru.blogspot.com/2009/05/blender-ge.html>`__ в
блоге про создание динамического текста в BGE. Скачал пример оттуда, всё
было прекрасно, я был счаслив, но… потом я решил поредактировать
текстуру прямо в Blender редакторе и сохранить на диск. Включил опцию
редактирования.

.. class:: text-center

|image0|

Потом я просто зарисовал символ “@” на текстуре.

.. class:: text-center

|image1|

Ничто не предвещало беды, т.к. я всё выполнил правильно, текст
отображался и работал в игровом движке. Но когда я сохранил файл на
диск, а потом попытался создать новый проект в Blender (использую
2.48a), то получилась какая то ерунда. Больше текст не отображался, а
лишь какое-то странное повторение символов “@”, которые были старательно
мной “замылены” (т.е. вместо текста были одни “собаки”).

Тогда мне пришла мысль, что оно где-то хранит данные о позициях
символов, размера и внутренний редактор Blender’а просто для удобства
редактирования убирает “лишнее”.

Так оно и оказалось. После долгих мучений и сравнений изображения из
примера и моего “редактирование”  я обратил внимаение на небольшое
различие: на эталонной картинке вверху присутствовало приблизительно 4
пикселя высотой “мусора”, состоящего из оттенков серого. Эта информация
была сгенерирована скриптом из туториала, но не отображалась в редакторе
Blender.

.. class:: text-center

|image2|

Сначала я озхнакомился с текстом Python скрипта **blendFont.py**,
обратил внимание на `функцию <http://pastebin.com/f2d827021>`__ putPix.
Понял, что она записывает байты данных, как пиксели прямо на картинку
при помощи цвета. Потом я решил поковыряться в исходниках Blender и
найти, где же оно проверяет соответствие формату и парсит заголовок.

Так я пришёл к файлу **source/blender/blenkernel/intern/bmfont.c**. Там
расположены две интересные функции *detectBitmapFont*\ (ImBuf \*ibuf) и
*readBitmapFontVersion0*\ (ImBuf \*ibuf, unsigned char \*rect, int
step). Указатель ibuf->rect ссылается на участок байтов, который
содержит пиксельные данные.

Если rect[0], rect[1], rect[2] и rect[3] равны символам ‘B’, ‘F’, ‘N’,
‘T’, то данное изображение 8-битное. Если эта проверка не ыполнилась, то
считается, что картинка 32-битная и проверяется rect[0], rect[4],
rect[8], rect[12] со смещениями от 0 до 4. Если заголовок был найден, то
вызывается readBitmapFontVersion, ей передаётся по сколько нужно читать
байтов, пр 32-битном изображении - по 4 байта на пиксель.

Формат текстуры для шрифта выглядит таким образом (это стало ясно после
обзора исходного кода readBitmapFontVersion):

-  4 байта для magic-последовательности (BFNT)
-  2 байта для версии
-  2 байта - количество глифов
-  размер по X - 2 байта
-  размер по Y - 2 байта

Затем  идёт описание каждого из символов (ровно столько сколько указано
в заголовке):

-  уникодный символ - 2 байта
-  позиция левого верхнего угла для символа на текстуре (LocX - 2 байта,
   LocY - 2 байта)
-  смещение (OfsX - 1 байт, OfsY - 1 байт)
-  размер в пикселях (SizeX - 1 байт, SizeY - 1 байт)
-  advance - 1 байт
-  1 байт зарезервирован

.. |image0| image:: http://img-fotki.yandex.ru/get/3606/imdagger.0/0_c451_45828fd2_L
   :target: http://fotki.yandex.ru/users/imdagger/view/50257/
.. |image1| image:: http://img-fotki.yandex.ru/get/3501/imdagger.0/0_c452_4cc20671_L
   :target: http://fotki.yandex.ru/users/imdagger/view/50258/
.. |image2| image:: http://img-fotki.yandex.ru/get/3607/imdagger.0/0_c467_b6603cc7_L
   :target: http://fotki.yandex.ru/users/imdagger/view/50279/
