Бесконечная блокировка
======================
:date: 2013-02-05 20:41:33
:modified: 2013-02-05 20:43:08
:tags: пул, неявный, pool, блокировка, gevent, python
:category: text
:author: IMDagger
:yaru-link: http://imdagger.ya.ru/replies.xml?item_no=1739

Как получить ситуацию, что gevent выдаст исключение о бесконечно
блокирующейся операции? Сделать бесконечный цикл? Нет. Достаточно, чтобы
операция сама себя ожидала, но как это сделать неявным образом, чтобы
пример не был высосан из пальца и был похож на настоящую ситуацию.
Достаточно просто.

Допустим есть потребность выполнять какую-то операцию (например
краулинг и парсинг страниц) в ограниченном количестве параллельных
потоком. Мы берём для этого пул с ограниченным размером. Затем для
каждой страницы мы хотим порождать отдельный поток (т.к. микропотоки
достаточно дешёвые), мы пишем что-то типа такого:

.. code-block:: pycon

    >>> p = gevent.pool.Pool(10)
    >>> for _ in xrange(5):
    ...       p.spawn(task, ...)
    ... p.join()



Затем реализуем задачу task, в ней будут выполняться какие-то
операции над полученными данными, например, извлекаться новые ссылки, и
будет происходить порождение новых микропотоков. Но мы же хотим, чтобы
конкуренция не разрасталась, поэтому решаем складывать задачи единый
пул.

.. code-block:: pycon

        >>> def sub_task(i, p):
                p.spawn(lambda: i)
        >>> def task(i, p):
        ...     for _ in xrange(4):
        ...         p.spawn(sub_task, i + 1, p)
        ...

Таким образом каждый task создаёт ещё по 4 sub\_task. Когда
структура программы не такая простая и голая, а напичкана различной
дополнительной логикой, то кажется, что всё хорошо. Но увы программа
начинает себя странно вести от раза к разу. И поведение меняется от
количества операция и размера пула.

В версии gevent 0.13.8 всё просто замолкает, зависает и крутится в
цикле. Но благо 1.0dev умеет определять эту проблемную точку и выдавать
исключение:

.. code-block:: pytb

        Traceback (most recent call last):
          File "test.py", line 14, in
            p.join()
          File "/home/imdagger/Projects/bj-project/virtualenv/pg/local/lib/python2.7/site-packages/gevent/pool.py", line 100, in join
            self._empty_event.wait(timeout=timeout)
          File "/home/imdagger/Projects/bj-project/virtualenv/pg/local/lib/python2.7/site-packages/gevent/event.py", line 77, in wait
            result = self.hub.switch()
          File "/home/imdagger/Projects/bj-project/virtualenv/pg/local/lib/python2.7/site-packages/gevent/hub.py", line 331, in switch
            return greenlet.switch(self)
        gevent.hub.LoopExit: This operation would block forever

А всё потому, что некоторая задача task нуждается в добавлении в пул
подзадачи sub\_task, которая тоже нуждается в пуле, а сам пул нуждается
в завершении задачи task, т.к. он достиг размера 10 и переполнен. и с
другими задачами аналогично, т.е. пул переполнен и ждёт освобождения, а
задачи, чтобы завершится пытаются в него затолкнуть ещё больше подзадач.

Поэтому для выхода из такой ситуации лучше обойтись либо только task
без вызова ещё одной поздадачи со spawn, а лучше вообще закидывать
подзадачи в очередь, а другой поток (или несколько), будут забирать их,
обрабатывать данные и укладывать в пул.
