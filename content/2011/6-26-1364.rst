Часть перевода из истории GoboLinux
===================================
:date: 2011-06-26 01:50:34
:tags: GoboLinux, статья, часть, перевод, linux
:category: text
:author: IMDagger
:yaru-link: http://imdagger.ya.ru/replies.xml?item_no=1364

Перевёл (глаза уже закрываются, утро же… спать хочется, почему я
решил под утро перевести эту статью я не знаю) чуть больше половины вот
этой `статьи <http://www.gobolinux.org/index.php?lang=en_US&page=k5>`__.
Завтра пеерведу остаток и отправлю на сайт создателей:

Hisham Muhammad, 09 Мая 2003.

За последнее время было множество споров о текущем состоянии Linux
как настольной системы, и статьи всплывали тут и там, иногда с очень
хорошими идеями. Однако ничто меня не удивило более, чем одна из них.
Она была вся очень гипотетическая, но имела довольно радикальные идеи
относительно того, как по их мнению дерево каталогов Linux должно быть
реорганизовано. Это несомненно была наиболее полемичная часть статьи, и
вызвала много дискуссий, о том возможно ли реализовать нечто подобное.
Это и есть причина для моего удивления, т.к. мы это реализовали более
года назад. GoboLinux это дистрибутив Linux основанный на альтернативном
дереве каталогов, которое развилось из самодельной инсталляции LFS в
дистрибутив, который сегодня используется и поддерживается небольшой
группой людей. Было любопытно наблюдать как множество людей
заинтересовано в идеях похожих на наши. Что ж, возможно это время для
нас, чтобы выйти из тени.

Немного истории

Мы все помним время, когда разговор о дистрибутивах Linux для
настольных компьютеров подразумевал спор какой из них имеет лучший
инсталлятор. Многое изменилось с тех пор: лёгкие, графические
инсталляторы уже здесь, но мы всё ещё не там, где нужно. Из числа
обычных напыщенных речей на тему «почему (вписать наболевшее сюда) это
проблема», некоторые интересные идеи появляются время от времени. Ещё
интереснее то, что некоторые люди начинали верить что возможно это время
для более рискованных попыток.

Как ни странно, то GoboLinux не начался как одна из таковых. Всё
началось когда мне нужно было установить программы в Университете.  Т.к.
я не имел доступа на запись в стандартные Unix-директории, то я создавал
мои собственные директории в $HOME тем способом, как я видел это. Я
обновлял программы из исходных кодов постоянно, и не мог использовать
пакетный менеджер. Моё решение было наиболее очевидным: размещать каждую
программу в её собственной директории, например ~/Programs/AfterStep.
Вскоре переменные среды (PATH, LD\_LIBRARY\_PATH…) становились всё
больше и больше, тогда я сделал централизованные директории для каждого
класса файлов, содержащих символические ссылки: ~/Libraries, ~/Headers и
т.д. Естественным продолжением было написать сценарии командной
оболочки, чтобы управлять ссылками, скриптами конфигурации и
Make-файлами.

Такой подход доказал, что очень удобен в использовании. На моей
домашней системе я начал постепенно удалять ранее собранные пакеты и
перекомпилировать их с помощью тех скриптов. Я занимался перемещением
полностью самодельной Linux системы, которую в шутку называл LodeLinux.
Когда около 80% от всего было завершенного, выскочил Великий Сбой
Файловой Системы. Это было время начать всё сначала, но в этот раз по
другому пути: вместо «деконструирования» существующего дистирбутива, я
(Hisham Muhammad) и мой друг, André Detsch, потратили два дня собирая
модифицированную Linux From Scratch систему. Без особой суеты, 20 Марта
2002 родился GoboLinux. Месяц спустя мы представили статью в 3-ем
Workshop в Free Software названную «Новое предложение для дерева
каталогов Unix».

О чём вообще всё это?

GoboLinux явно не «просто ещё один Linux дистрибутив для
настольного компьютера». Он целиком базируется на альтернативной
структуре директорий. Каждая программа живёт в её собственной
директории: Вы найдёте XFree86 4.3 в /Programs/XFree86/4.3/, и ping в
/Programs/Netkit-Base/0.17/bin/ping. Чтобы просмотреть что за программы
инсталлированны в системе достаточно просто сделать ls /Programs.

Для каждой категории файлов есть директория в /System/Links
группирующая файлы из каждого приложения как символические ссылки:
Executables, Libraries, Headers, Shared и Manual. Для совместимости,
каждая “традиционная” директория это ссылка на соответствующую
категорию. Более того /bin, /sbin, /usr/bin, /usr/local/bin (и т.д.)
просто символические ссылки на /System/Links/Executables. Переменные
среды тоже очень простые: достаточно сделать :code:`export
PATH=/System/Links/Executables`.

Коротко говоря, то что мы имеем это система управления пакетами без
базы данных, структура директорий сама по себе организует систему (разве
не это было её первоначальной целью в конце концов?). Каждая директория
программы (например, /Programs/KDE) содержит директории с каталогами
версий (/Programs/KDE/3.0, /Programs/KDE/3.1.1), и безверсионную
директорию для настроек (/Programs/KDE/Settings), чтобы хранить файлы,
которые обычно хранились бы в /etc. Поддерживание двух и более версий
библиотек тривиально. Когда большинство дистрибутивов переключилось на
GCC3 они выпустили новую старшую версию, по большому счёту не
совместимую с предыдущими. Когда в версии 006 GoboLinux адаптировали
GCC3, это было лишь вопросом поддержания старых версий библиотек рядом с
новыми, пока они полностью постепенно не были бы убраны. Никаких
«пакетов совместимости» не потребовалось.

Большинство задач в GoboLinux автоматизированы набором скриптов.
Чтобы создать GoboLinux пакет, нужно всего лишь написать нечто подобное
на CreatePackage CoreUtils. Всё, что делает данная комманда — это
сохраненяет CoreUtils/5.0/ и CoreUtils/Settings в .tar.bz2 файл с
названием CoreUtils–5.0–i686.tar.bz2. Ссылка с названием
/Programs/CoreUtils/Current показывает какая версия на данным момент
действует. Она используется скриптами как ‘версия по умолчанию’.
Установка программы управляется тремя скриптами: PrepareProgram, который
создаёт /Programs/ иерархию и передаёт подходящие опции для configure.
SymlinkProgram создаёт ссылки в /System/Links. Скрипт обёртка
CompileProgram заменяет обычный :code:`configure && make && make install` подход
(с множеством опций командной строки, чтобы учесть особые случаи).

Альтернативные скрипты загрузки

С того момента как мы почувствовали, что мы «строим с нуля» и мы
хотим делать систему, где всё значимо для нас, мы также потратили время
на то, чтобы перепродумать сценарии загрузки. Я ощущал, что две
исторические модели (System V и BSD) были перебором для нашей установки
на обычном настольном компьютере. GoboLinux использует систему попроще:
два скрипта, Init и Done, которые делают большинство работы.
Дополнительные скрипты такие как Multi и Single заботятся об runlevel-е.
Эти файлы просто последовательность комманд, начинающихся со слова Exec
и строки с сообщением. Вот выдержка из Init:

  | Exec "Setting clock..." SetClock
  | Exec "Loading keymap..." loadkeys "$KeymapLayout"
  | Exec "Bringing up the loopback interface..." ifconfig lo 127.0.0.1

Более сложные задачи такие как SetClock объявлены, как функции
командной оболочки в файле Tasks (эти задачи могут быть также вызваны из
командной строки используя Runtask скрипт). Настройки для
конфигурирования объявлены, как переменные среды в Options файле.
Функция обёртка Exec позволяет реализовать стильные дополнительные
возможности, такие как темы загрузок. Последовательность загрузки может
выглядеть как Slackware подобная (с обычными сообщениями в поток
стандартного вывода/ошибки), похожая на RedHat (с множеством OK), или в
стиле GoboLinux (последний использует модифицированную версию Linux
Progress Patch).
