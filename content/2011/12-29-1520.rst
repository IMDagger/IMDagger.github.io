RequireJS модули
================
:date: 2011-12-29 00:55:53
:tags: загрузка, ошибка, программирование, радость, javascript, undefined, модуль, RequireJS, зависимость, работа
:category: text
:author: IMDagger
:yaru-link: http://imdagger.ya.ru/replies.xml?item_no=1520

Мне нужно было подправить странную проблему в JavaScript коде,
структура которого была написана не мной. Сервер возвращает некоторый
готовый HTML, который принимает клиентская сторона и превращает в DOM.
Возвращаемая страница содержала несколько тегов :code:`<script>`, я создал
несколько js-файлов, при чём B нуждался в A, и был после них тег
:code:`<script>` с прописанным кодом в шаблоне, где создавался экземпляр
прототипа из файла B.

И всё это счастье срабатывало на нажатие кнопки. Я обнаружил, что
кнопку приходится нажимать несколько раз. При чём странным образом
первый раз код выпадал с ошибкой и говорил, что не знает такой прототип
C и в помине (и что он undefined), хотя чуть выше был подключён
JavaScript-код для него.

Пару проб с **alert**-ами и выяснилось, что если этот участок кода
немного подождёт, то всё проходит из соринки и задоринки. Стало ясно,
что :code:`<script>` элементы обходятся в произвольном порядке и по мере
загрузки. В тот момент, когда блок кода исполнялся, протопит C ещё
загружался с сервера. Пришлось искать решения.

И оно нашлось `RequireJS <http://requirejs.org/>`__, что позволило
мне собрать части кода как модули и определить зависимости между ними. Я
не JavaScript разработчик, поэтому я раньше не особо задумывался, что в
JS есть такие проблемы и до этого не искал таких библиотек.

Но после того как я сделал модули меня ждал небольшой сюрприз
(документацию я смотрел невнимательно):

    | // a/b/c
    | define([], function() { … });
    | // mod/user
    | define([’a/b/c’, …], function (mod\_a) {
    |     ...\.
    |     **mod\_a undefined, т.к. модуль ничего не экспортирует**
    | });

Я ничего не возвращал из данной функции, почему-то подразумевая, что
всё как-то само отправится в глобальную видимость, хотя сто раз прочёл в
доке про указание на анонимную функцию и т.д.

А затем час волосы на себе рвал пытаясь понять почему mod\_a
переменная undefined и не содержит заветного модуля. Оказалось, что
функция возвращает словарь с данными, которые модуль экспортирует.

    | // a/b/c
    | define([], function() { … return {exported: MyMegaProto}; });
    | // mod/user
    | define([’a/b/c’, …], function (mod\_a) {
    |     ...
    |     **использовать mod\_a.exported**
    |     ...
    |     return … // то что экспортируем
    | });
